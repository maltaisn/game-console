#!/usr/bin/env python3

#  Copyright 2022 Nicolas Maltais
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Command line program used to program the game console.
# The game console is connected via a UART link, which is connected to a USB serial device.
# This program can:
# - Check the system & bootloader version.
# - Raw access to read and write to EEPROM
# - Raw access to read & write to flash
# - Install apps
# - Uninstall apps
# - List installed apps
#
# Usage:
#  ./gcprog.py -v
#  ./gcprog.py --help
#  ./gcprog.py <command> --help
#  ./gcprog.py [options] <command> [command options]
#
# At least Python 3.7 is required.

import argparse
import signal
import sys
from typing import Optional

import prog.app as app
import prog.eeprom as eeprom
import prog.flash as flash
import prog.memory as memory
from prog.comm import Comm, ProgError, Packet, PacketType, CommInterface
from prog.spi import SpiInterface
from utils import DataReader

VERSION = 3

STD_IO = "-"

EEPROM_LOCAL_FILE = "dev/eeprom.dat"
FLASH_LOCAL_FILE = "dev/flash.dat"

# try:
#     import pydevd_pycharm
#
#     pydevd_pycharm.settrace('localhost', port=5678, stdoutToServer=True, stderrToServer=True)
# except ConnectionRefusedError:
#     pass

parser = argparse.ArgumentParser(description="Programming utility for the game console.")
parser.add_argument(
    "-d", "--device", action="store", type=str, dest="device", default=Comm.DEFAULT_FILENAME,
    help=f"UART device filename (default is {Comm.DEFAULT_FILENAME})")
parser.add_argument(
    "-v", "--version", action="store_true", dest="version",
    help="Show utility version, and device version info if connected")
parser.add_argument(
    "--local", action="store_true", dest="local_run",
    help="Enable local run, no connection is made, flash and EEPROM are simulated using "
         "local files.")
parser.add_argument(
    "--sim", action="store_true", dest="simulator",
    help="Connect to the simulator socket instead of the actual device.")

subparsers = parser.add_subparsers(dest="command")

# init command
init_parser = subparsers.add_parser(
    "init", help="Perform device initialization",
    description="Perform device initialization, writing signature bytes to the flash and EEPROM "
                "device and initializingthe index sections. If the device is already initialized, "
                "nothing will be done.")

# install command
install_parser = subparsers.add_parser(
    "install", help="Install or update an app.",
    description="Install or update apps. This command will update the flash index, write the "
                "app image to the flash, update the EEPROM index, allocate and initialize a "
                "segment of the EEPROM reserved to the app. When updating an app, the exisiting "
                "EEPROM space will be reallocated if its size changed. "
                "By default, install will fail if the version of the app is older than the "
                "currently installed version. Install will also fail if the device is out of "
                "space. Note that if write verification fails, this operation should be retried"
                "before booting to ensure a correct state of the indices.")
install_parser.add_argument(
    "apps", action="store", type=str, nargs="+",
    help="App image files, generated by the packer. Multiple apps can be installed at once.")
install_parser.add_argument(
    "-U", "--no-update", action="store_true", default=False, dest="no_update",
    help="Don't update, only install if the app isn't already installed.")
install_parser.add_argument(
    "-d", "--downgrade", action="store_true", default=False, dest="downgrade",
    help="If the new version is older than the installed version, allow downgrade.")
install_parser.add_argument(
    "--no-confirm", action="store_false", default=True, dest="confirm",
    help="Skip confirmation, install or update directly.")

# uninstall command
uninstall_parser = subparsers.add_parser(
    "uninstall", help="Uninstall an app",
    description="Uninstall apps by ID. This command will remove the apps from the flash and EEPROM "
                "indices, but won't clear their data from memory. The EEPROM entry can optionally "
                "be kept while still uninstalling the app. Note that if write verification fails, "
                "this operation should be retried before booting to ensure a correct state of the "
                "indices.")
uninstall_parser.add_argument(
    "ids", action="store", type=int, nargs="+",
    help="App IDs. Multiple apps can be uninstalled at once.")
uninstall_parser.add_argument(
    "-C", "--keep-data", action="store_false", default=True, dest="clear_data",
    help="Keep the EEPROM data for the app after uninstalling.")
uninstall_parser.add_argument(
    "--no-confirm", action="store_false", default=True, dest="confirm",
    help="Skip confirmation, uninstall directly.")

# data command
data_parser = subparsers.add_parser(
    "data", help="Read, write or erase EEPROM data for an app.",
    description="Read, write or erase EEPROM data for an app. Erasing data writes zeroes to the "
                "reserved EEPROM segment for the app, without changing the EEPROM index. "
                "Writing data will not take any effect beyond the app reserved space.")
data_parser.add_argument(
    "app_id", action="store", type=int,
    help="App ID.")
data_parser.add_argument(
    "-r", "--read", type=str, default='', dest="read_file",
    help="Read all EEPROM data for the app and store it in a file.")
data_parser.add_argument(
    "-w", "--write", type=str, default='', dest="write_file",
    help="Overwrite all EEPROM data for the app from a file.")
data_parser.add_argument(
    "-e", "--erase", action="store_true", default=False, dest="erase",
    help="Clear all EEPROM data for the app.")
data_parser.add_argument(
    "--no-confirm", action="store_false", default=True, dest="confirm",
    help="Skip confirmation, do the operation directly.")

# list command
list_parser = subparsers.add_parser(
    "list", help="List and describe installed apps",
    description="List and describe installed apps: title, version, author, build date, size, "
                "EEPROM reserved size, targeted bootloader version. "
                "Total flash and EEPROM usage are also reported.")

# eeprom command
memory.create_parser(subparsers, eeprom.EEPROM_SIZE, "EEPROM")

# flash command
memory.create_parser(subparsers, flash.FLASH_SIZE, "flash")


class Prog(CommInterface):
    """Class used to interpret command line arguments and execute commands."""
    args: argparse.Namespace
    local_run: bool
    comm: Comm

    flash: memory.MemoryDriver
    eeprom: memory.MemoryDriver

    system_version: Optional[int]
    boot_version: Optional[int]
    system_version_comp: Optional[int]

    interrupted: bool
    operation_in_progress: bool
    fast_mode_enabled: bool

    def __init__(self, args):
        self.args = args
        self.local_run = args.local_run
        self.interrupted = False
        self.operation_in_progress = False
        self.fast_mode_enabled = False
        signal.signal(signal.SIGINT, self.sigint_handler)

        if args.local_run and args.simulator:
            raise ProgError("--local and --sim options are mutually exclusive")

        # connect to serial device
        self.comm = Comm(args.device, simulator=self.args.simulator)
        self.system_version = None
        self.boot_version = None
        self.system_version_comp = None

        if self.local_run:
            self.eeprom = eeprom.EepromDriver.local(EEPROM_LOCAL_FILE)
            self.flash = flash.FlashDriver.local(FLASH_LOCAL_FILE)
        else:
            self.eeprom = eeprom.EepromDriver(SpiInterface(self))
            self.flash = flash.FlashDriver(SpiInterface(self))

    def do_command(self) -> None:
        if not self.local_run:
            try:
                self.comm.connect()
            except ProgError as e:
                if not self.args.version:
                    raise ProgError(e)

        self.get_version()
        if self.args.version:
            self.print_version()
            return
        self.check_version()

        self.set_fast_baud_rate(True)

        cmd = self.args.command
        if cmd == "eeprom":
            self.command_eeprom()
        elif cmd == "flash":
            self.command_flash()
        elif cmd == "init":
            self.command_init()
        elif cmd == "install":
            self.command_install()
        elif cmd == "uninstall":
            self.command_uninstall()
        elif cmd == "data":
            self.command_data()
        elif cmd == "list":
            self.command_list()

        if self.local_run:
            self.eeprom.save()
            self.flash.save()

        self.set_fast_baud_rate(False)
        self.comm.disconnect()

    def get_version(self) -> None:
        if self.local_run:
            self.system_version = 0
            self.boot_version = 0
            self.system_version_comp = VERSION
        elif self.comm.is_connected():
            self.write(Packet(PacketType.VERSION))
            version = self.read(PacketType.VERSION).payload
            reader = DataReader(version)
            self.system_version = reader.read(2)
            self.boot_version = reader.read(2)
            self.system_version_comp = reader.read(2)

    def check_version(self) -> None:
        if self.system_version_comp > VERSION:
            raise ProgError(f"gcprog version ({VERSION}) is not compatible with "
                            f"system version (min {self.system_version_comp} required)")

    def print_version(self) -> None:
        print(f"gcprog v{VERSION}")
        if self.system_version:
            print(
                f"bootloader v{self.boot_version}, system v{self.system_version}, "
                f"compatible with gcprog v{self.system_version_comp}")

    def interrupt_exit(self) -> None:
        self.interrupted = False
        if self.fast_mode_enabled:
            self.set_fast_baud_rate(False)
        self.comm.disconnect()
        exit(1)

    def write(self, packet: Packet) -> None:
        """Packet write wrapper around Comm.write to ensure that write operation
        is not interrupted and to ensure that RX is flushed afterwards if interrupted."""
        self.operation_in_progress = True
        self.comm.write(packet)
        if self.interrupted:
            # a packet was possibly returned, discard it (introduces a small delay).
            self.comm.serial.read_all()
            self.interrupt_exit()
        self.operation_in_progress = False

    def read(self, expected_type: Optional[PacketType] = None) -> Packet:
        """Packet read wrapper around Comm.read to ensure that read operation is not interrupted."""
        self.operation_in_progress = True
        packet = self.comm.read(expected_type)
        if self.interrupted:
            self.interrupt_exit()
        self.operation_in_progress = False
        return packet

    def set_fast_baud_rate(self, enabled: bool) -> None:
        if self.local_run:
            return
        self.write(Packet(PacketType.FAST_MODE, [0x01 if enabled else 0x00]))
        self.comm.serial.flush()
        self.fast_mode_enabled = enabled
        self.read(PacketType.FAST_MODE)
        self.comm.set_fast_baud_rate(enabled)

    def sigint_handler(self, signum, frame):
        if self.operation_in_progress:
            self.interrupted = True
        else:
            self.interrupt_exit()

    def create_app_manager(self) -> app.AppManager:
        manager = app.AppManager(self.eeprom, self.flash)
        manager.boot_version = self.boot_version
        return manager

    def command_eeprom(self) -> None:
        config = memory.create_config(eeprom.EEPROM_SIZE, self.args)
        memory.execute_config(self.eeprom, config)

    def command_flash(self) -> None:
        config = memory.create_config(flash.FLASH_SIZE, self.args)
        memory.execute_config(self.flash, config)

    def command_init(self) -> None:
        manager = self.create_app_manager()
        manager.initialize()

    def command_install(self) -> None:
        manager = self.create_app_manager()
        manager.confirm = self.args.confirm
        manager.install_all(self.args.apps, self.args.no_update, self.args.downgrade)

    def command_uninstall(self) -> None:
        manager = self.create_app_manager()
        manager.confirm = self.args.confirm
        manager.uninstall_all(self.args.ids, self.args.clear_data)

    def command_data(self) -> None:
        manager = self.create_app_manager()
        app_id = self.args.app_id
        if self.args.read_file:
            manager.read_eeprom(app_id, self.args.read_file)
        if self.args.erase and self.args.write_file:
            raise ProgError("cannot write and erase at the same time")
        elif self.args.write_file:
            manager.write_eeprom(app_id, self.args.write_file)
        elif self.args.erase:
            manager.erase_eeprom(app_id)

    def command_list(self) -> None:
        self.create_app_manager().list_all()


def main() -> None:
    args = parser.parse_args()
    try:
        prog = Prog(args)
        prog.do_command()
    except ProgError as e:
        print(f"ERROR: {e}.", file=sys.stderr)
        exit(1)


if __name__ == '__main__':
    main()
