#  Copyright 2022 Nicolas Maltais
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

from typing import Optional, Iterable, TextIO, Union

from assets.types import Location
from utils import PathLike


class CodeWriter:
    """Lower level C code writer."""
    file: TextIO

    def __init__(self, filename: PathLike):
        self.file = open(filename, "w")

    def close(self) -> None:
        self.file.close()

    def directive(self, name: str, value: Optional[str] = None) -> None:
        self.file.write(f"#{name}")
        if value:
            self.file.write(f" {value}")
        self.file.write("\n")

    def comment(self, value: str) -> None:
        self.file.write(f"// {value}\n")

    def _array(self, name: str, data_type: str,
               constant: bool = False, extern: bool = False) -> None:
        if extern:
            self.file.write("extern ")
        if constant:
            self.file.write("const ")
        self.file.write(f"{data_type} {name}[]")

    def array(self, name: str, data_type: str, data: Optional[Iterable[int]] = None, *,
              constant: bool = False, extern: bool = False) -> None:
        self._array(name, data_type, constant, extern)
        if data is None:
            self.file.write(";\n")
        else:
            self.file.write(" = {")
            max_value_size = len(f"{max(data):x}")
            for i, value in enumerate(data):
                if i % 8 == 0:
                    self.file.write("\n        ")
                self.file.write(f"0x{f'{value:x}'.rjust(max_value_size, '0')}, ")
            self.file.write("\n};\n\n")

    def ptr_array(self, name: str, data_type: str, data: Optional[Iterable[str]] = None, *,
                  constant: bool = False, extern: bool = False) -> None:
        self._array(name, data_type, constant, extern)
        if data is None:
            self.file.write(";\n")
        else:
            self.file.write(" = {")
            for value in data:
                self.file.write(f"\n        {value},")
            self.file.write("\n};\n\n")

    def space(self, n: int = 1) -> None:
        for i in range(n):
            self.file.write("\n")


class CodeGenerator:
    """Basic C code generator for generating assets header and source."""
    header: CodeWriter
    source: Optional[CodeWriter]
    source_written: bool

    INT_MAX = 0xffff
    ADDRESS_WIDTH = 4

    def __init__(self, header_filename: PathLike, source_filename: Optional[PathLike],
                 import_flash: bool):
        self.header = CodeWriter(header_filename)
        self.source = CodeWriter(source_filename) if source_filename else None
        self.source_written = False

        h = self.header
        h.comment("file auto-generated by assets packer, do not modify directly")
        h.directive("ifndef", "ASSETS_H")
        h.directive("define", "ASSETS_H")
        h.space()
        h.directive("include", "<core/data.h>")
        if source_filename:
            h.directive("include", "<core/defs.h>")  # for uintN_t
        if import_flash:
            h.directive("include", "<core/flash.h>")  # for flash_read
        h.space()

        s = self.source
        s.comment("file auto-generated by assets packer, do not modify directly")
        s.directive("include", '"assets.h"')
        s.space()

    def end(self) -> None:
        h = self.header
        h.directive("endif")
        h.close()

        s = self.source
        s.close()

    def add_define(self, name: str, value: Union[str, int], is_hex: bool = False,
                   location: Optional[Location] = None) -> None:
        if isinstance(value, int):
            if is_hex:
                value_str = f"0x{f'{value:x}'.rjust(CodeGenerator.ADDRESS_WIDTH, '0')}"
            else:
                value_str = str(value)
            if value > CodeGenerator.INT_MAX:
                value_str += "L"
        else:
            value_str = value
        if location:
            value_str = f"data_{location.value}({value_str})"
        self.header.directive("define", f"{name.upper()} {value_str}")

    def add_macro(self, name: str, args: Iterable[str], value: str,
                  location: Optional[Location] = None) -> None:
        if location:
            value = f"data_{location.value}({value})"
        else:
            value = f"({value})"
        self.header.directive("define", f"{name}({', '.join(args)}) {value}")

    def add_array(self, name: str, type_width: int, data: Iterable[int]) -> None:
        name = name.upper()
        data_type = f"uint{type_width * 8}_t"
        self.header.array(name, data_type, constant=True, extern=True)
        self.source.array(name, data_type, data, constant=True)
        self.source_written = True

    def add_ptr_array(self, name: str, type_width: int, data: Iterable[str]) -> None:
        name = name.upper()
        data_type = f"uint{type_width * 8}_t*"
        self.header.ptr_array(name, data_type, constant=True, extern=True)
        self.source.ptr_array(name, data_type, data, constant=True)
        self.source_written = True

    def add_separator(self):
        self.header.space()
